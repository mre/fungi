* pseudocode

** delete_dups

without buffer

#+begin_example
deleteDups(LinkedListNode head) {
    if (head == null) return;
    LinkedListNode previous = head;
    LinkedListNode current = previous.next;
    while (current != null) {
        LinkedListNode runner = head;
        while (runner != current) { // Check for earlier dups
            if (runner.data == current.data) {
                LinkedListNode tmp = current.next; // remove current
                previous.next = tmp;
                current = tmp; // update current to next node
		break; // all other dups have already been removed
	    }
            runner = runner.next;
        }
        if (runner == current) { // current not updated - update now
            previous = current;
            current = current.next;
        }
    }
}
#+end_example

** find_beginning

#+begin_example
LinkedListNode FindBeginning(LinkedListNode head) {
    LinkedListNode n1 = head;
    LinkedListNode n2 = head;

    // Find meeting point
    while (n2.next != null) {
        n1 = n1.next;
        n2 = n2.next.next;
        if (n1 == n2) {
            break;
        }
    }
    // Error check - there is no meeting point, and therefore no loop
    if (n2.next == null) {
        return null;
    }
    /* Move n1 to Head. Keep n2 at Meeting Point. Each are k steps
    /* from the Loop Start. If they move at the same pace, they must
    ,* meet at Loop Start.
    ,*/
    n1 = head;
    while (n1 != n2) {
        n1 = n1.next;
        n2 = n2.next;
    }
    // Now n2 points to the start of the loop.
    return n2;
}
#+end_example

** is_reachable

Given a directed graph, design an algorithm to find out whether there is
a route between two nodes.

#+begin_example
enum {
  unvisited // default
  visiting
  visited
}

fn find(g: graph, target: node, start: node) {
    stack: Vec<Node>;
    nodes: Vec<Node> = g.nodes();
    start.visiting;
    stack.push(start);
    for current in nodes.pop() {
        for u in current.adiacents() {
            if u != unvisited {
                continue;
            }
            if u == end {
                return true;
            }
            u.visiting;
            stack.push(u);
        }
        current.visited;
    }
    return false;
}
#+end_example

** vec_to_binary_tree

Given a sorted (increasing order) array, write an algorithm to create a
binary tree with minimal height.

#+begin_example
fn add(nodes: Vec<i32>, start: usize, end: usize) -> Option(node) {
    if start > end {
        return None;
    }
    //       4     6     9
    // ......|.....|.....|......
    middle = (start + end ) / 2;
    n: Node(nodes[middle]);
    n.left = add(nodes, 0, middle - 1);
    n.right = add(nodes, middle + 1, end);
    return n;
}

fn to_binary(nodes: Vec<i32>) -> node {
    return add(nodes, 0, nodes.len() - 1);
}
#+end_example

** vec_at_depth

Given a binary search tree, design an algorithm which creates a linked
list of all the nodes at each depth (eg, if you have a tree with depth
D, you’ll have D linked lists).

#+begin_example
fn graph_to_list_of_vec_by_depth(root: Node) -> Vec<Vec<Node>> {
    result = Vec::new();
    list = Vec::new();
    level = 0;
    list.push(root);
    result[level] = list;
    loop {
        list = Vec::new();
        for n in result[level] {
	    list.push(n.left);
            list.push(n.right);
        }
        if list.len() > 0 {
	    level ++;
	    result[level] = list;
        } else {
            break;
        }
    }
    return result;
}
#+end_example

** tree traversal

[[https://en.wikipedia.org/wiki/Tree_traversal#Depth-first_search][Tree traversal (wikipedia.com)]]

Traversing a tree involves iterating over all nodes in some
manner. Because from a given node there is more than one possible next
node (it is not a linear data structure), then, assuming sequential
computation (not parallel), some nodes must be deferred—stored in some
way for later visiting. This is often done via a stack (LIFO) or queue
(FIFO). As a tree is a self-referential (recursively defined) data
structure, traversal can be defined by recursion or, more subtly,
corecursion, in a very natural and clear fashion; in these cases the
deferred nodes are stored implicitly in the call stack.

Depth-first search is easily implemented via a stack, including
recursively (via the call stack), while breadth-first search is easily
implemented via a queue, including corecursively.

*** Depth-first search

Main article: Depth-first search

These searches are referred to as depth-first search (DFS), as the
search tree is deepened as much as possible on each child before going
to the next sibling. For a binary tree, they are defined as display
operations recursively at each node, starting with the root, whose
algorithm is as follows:

The general recursive pattern for traversing a (non-empty) binary tree
is this: At node N do the following:

- (L) Recursively traverse its left subtree. This step is finished at
  the node N again.
- (R) Recursively traverse its right subtree. This step is finished at
  the node N again.
- (N) Process N itself.

These steps can be done in any order. If (L) is done before (R), the
process is called left-to-right traversal, otherwise it is called
right-to-left traversal. The following methods show left-to-right
traversal:

*** Pre-order (NLR)

Pre-order: F, B, A, D, C, E, G, I, H.

- Check if the current node is empty or null.
- Display the data part of the root (or current node).
- Traverse the left subtree by recursively calling the pre-order function.
- Traverse the right subtree by recursively calling the pre-order function.

The pre-order traversal is a topologically sorted one, because a parent
node is processed before any of its child nodes is done.

: preorder(node)
:   if (node = null)
:     return
:   visit(node)
:   preorder(node.left)
:   preorder(node.right)

*** In-order (LNR)

In-order: A, B, C, D, E, F, G, H, I.

- Check if the current node is empty or null.
- Traverse the left subtree by recursively calling the in-order function.
- Display the data part of the root (or current node).
- Traverse the right subtree by recursively calling the in-order function.

In a binary search tree, in-order traversal retrieves data in sorted order

: inorder(node)
:   if (node = null)
:     return
:   inorder(node.left)
:   visit(node)
:   inorder(node.right)

*** Out-order (RNL)

- Check if the current node is empty or null.
- Traverse the right subtree by recursively calling the out-order function.
- Display the data part of the root (or current node).
- Traverse the left subtree by recursively calling the out-order function.

In a binary search tree, out-order traversal retrieves data in reverse
sorted order.

*** Post-order (LRN)

Post-order: A, C, E, D, B, H, I, G, F.

- Check if the current node is empty or null.
- Traverse the left subtree by recursively calling the post-order function.
- Traverse the right subtree by recursively calling the post-order function.
- Display the data part of the root (or current node).

: postorder(node)
:   if (node = null)
:     return
:   postorder(node.left)
:   postorder(node.right)
:   visit(node)

The trace of a traversal is called a sequentialisation of the tree. The
traversal trace is a list of each visited root. No one sequentialisation
according to pre-, in- or post-order describes the underlying tree
uniquely. Given a tree with distinct elements, either pre-order or
post-order paired with in-order is sufficient to describe the tree
uniquely. However, pre-order with post-order leaves some ambiguity in
the tree structure.

[[https://en.wikipedia.org/wiki/Breadth-first_search][Breadth-first search (wikipedia)]]

#+begin_example
levelorder(root)
  q ← empty queue
  q.enqueue(root)
  while (not q.isEmpty())
    node ← q.dequeue()
    visit(node)
    if (node.left ≠ null)
      q.enqueue(node.left)
    if (node.right ≠ null)
      q.enqueue(node.right)
#+end_example

** in_order_next

Write an algorithm to find the 'next' node (eg, in-order successor) of
a given node in a binary search tree where each node has a link to its
parent.

#+begin_example
fn in_order_next(n: Node) -> Option(Node) {
    // this is a node with a right branch; the next will be the node
    // in the left most position of this right sub-tree.
    if n.right.is_some {
        // find the left most node from the right branch starting from here.
        let l = n.right;
        while l.is_some {
            l = l.left;
        }
        // this is the leftmost node.
        return l;
    }
    // otherwise we look at its parent
    p = n.parent
    while p.is_some {
         // if the starting node was already the left node of its parent
         // we can return the parent because this will be the next in LNR.
         if p.left == n {
             // then the parent is the next
             break;
         }
         // otherwise we keep going up until we reach the left side.
         // the node to be considered will be the parent of the current one.
         n = p
         p = n.parent
     }
     return p;
}
#+end_example

given this tree with LNR traversal [A,B,C,D,E,F,G,H,I].

#+begin_example
     [ F ]
    /     \
   B       G
  / \       \
 A   D       I
    / \     /
   C   E   H
#+end_example

for example:

#+begin_example
- [G] has_right_node -> leftmost_of(I) -> return [H]
- [E] has_parent -> D.left != E
                 -> D.has_parent -> B.left != D
                                 -> B.has_parent -> F.left = B
                                                 -> return [E]
#+end_example

** common_ancestor_in_a_tree

Design an algorithm and write code to find the first common ancestor of
two nodes in a binary tree Avoid storing additional nodes in a data
structure NOTE: This is not necessarily a binary search tree.

#+begin_example
commonAncestor(Tree root, Tree p, Tree q) Tree {
  if (covers(root.left, p) && covers(root.left, q))
      return commonAncestor(root.left, p, q);
  if (covers(root.right, p) && covers(root.right, q))
      return commonAncestor(root.right, p, q);
  return root;
}

private boolean covers(Tree root, Tree p) { /* is p a child of root? */
    if (root == null) return false;
    if (root == p) return true;
    return covers(root.left, p) || covers(root.right, p);
}
#+end_example

** is_subtree

#+begin_example
// entry point of recursion
containsTree(TreeNode t1, TreeNode t2) bool {
    if (t2 == null) return true; // The empty tree is always a subtree
    else return subTree(t1, t2);
}

subTree(TreeNode r1, TreeNode r2) bool {
    // false if t1 (the biggest) is empty
    if (r1 == null) return false;
    // the we found the point where t2 starts in r1
    if (r1.data == r2.data) {
        // return true if r2 matches the subtree from this point
        if (matchTree(r1,r2)) return true;
    }
    // recursing, looking for another point where r2 starts in r1.
    return (subTree(r1.left, r2) || subTree(r1.right, r2));
}

matchTree(TreeNode r1, TreeNode r2) bool {
    if (r2 == null && r1 == null) return true;
    if (r1 == null || r2 != null) return false;
    if (r1.data != r2.data) return false;
    // if r1 and r2 are matching we fork and recurse on left and right.
    return (
        matchTree(r1.left, r2.left) &&
	matchTree(r1.right, r2.right));
    );
}
#+end_example

** find_sum

You are given a binary tree in which each node contains a value. Design
an algorithm to print all paths which sum up to that value. Note that it
can be any path in the tree. it does not have to start at the root.

// we don't stop when we find the sum because negative values can unblock
// different paths:
// sum 5): 2 + 3 + –4 + 3 + 1 + 2

#+begin_example
// start from the root, buffer empty and level 1
findSum(head: Option<Node>, sum: i32, buffer: Vec<i32>, level: i32) {
    // if the node is empty, we stop
    if (head == None) return;
    // let's take a mutable copy of the sum we want to check
    let mut tmp: i32 = sum;
    // we build the path up to this point
    buffer.push(head.data);
    // we decrease from here, doing "level" steps back in our path.
    for (int i = level; i >- 1; i--){
        // i is the current level we are checking
        tmp -= buffer.get(i);
        // if the sum is zero, we print the path, starting from i to level.
        if (tmp == 0) print(buffer, i, level);
    }
    // we don't stop at the sum even if was found, because we can find other
    // intermediate results.
    c1 buffer.clone();
    c2 buffer.clone();
    // forking left and right
    findSum(head.left, sum, c1, level + 1);
    findSum(head.right, sum, c2, level + 1);
}
print(buffer: Vec<i32>, start: i32, end: i32) {
    for (int i = start; i <= end; i++) {
        print(buffer.get(i) + " ");
    }
    println("---");
}
#+end_example

** update_bits

#+begin_example
fn updateBits(n: u32, m: u32, i: u32, j: u32) {
    // bitwise negation
    // max: 11111111111111111111111111111111
    let max:u32 = !0;
    println!("{:032b}", max);

    // 1's through position j, then 0's
    // 1 << 6 = 1000000
    // (1 << 6) - 1 = 0111111
    // left: 11111111111111111111111111000000
    let left: u32 = max - ((1 << j) - 1);
    println!("{:032b}", left);

    // 1's after position i
    // (1 << 2) - 1 = 00011
    let right: u32 = ((1 << i) - 1);

    // 1’s, with 0s between i and j
    // mask: 11111111111111111111111111000011
    int mask = left | right;
    println!("{:032b}", mask);

    // Clear i through j, then put m in there
    // n = 10000000000
    // m =       10101
    // n & mask = 0010000000000
    // shift left m
    // m = 10101
    // i = 2
    // m << 2 = 0000001010100
    // result = 10001010100
    return (n & mask) | (m << i);
}
#+end_example

** non_integer_binary

print a non-integer number.

by analogy to a decimal number, the number
n = 0.101 = 1 * (1/2^1) + 0 * (1/2^2) + 1 * (1/2^3).

parse_int(string(split_at('.'))

To print the decimal part

multiply by 2 and check if the 2*n is greater than or equal to one.
"shifting" the fractional sum.

r = 2*n = 2*0.101 = 1*(1 / 2^0) + 0*(1 / 2^1) + 1*(1 / 2^2) = 1.01

If r >= 1, then we know that n had a 1 right after the decimal point.

print the int part

: int_string: String = String::from("");
: while (int_n > 0) {
:     r: u32 = int_n % 2;
:     int_n >>= 1;
:     int_string = r + int_string;
: }

print the decimal part

: double r = decPart * 2;
: if (r >= 1) {
:     dec_string.append(1);
:     decPart = r - 1;
: } else {
:     dec_string.append(0);
:     decPart = r;
: }

** get_next_and_prev_by_ones

bruteforce

#+begin_example
// as_string: "101010"
// 41, 101001
// 44, 101100
// 42, (44, 41)

fn get_next_and_prev_by_ones(n: u32) -> (u32, u32) {
    let as_string: String = format!("{:b}", n);
    println!("as_string: {:?}", as_string);
    let mut ones: u32 = 0;
    for c in as_string.chars() {
        if c == '1' {
            ones += 1;
        }
    }
    let mut previous: u32 = n - 1;
    while previous > 0 {
        let mut p_ones: u32 = 0;
        let as_string: String = format!("{:b}", previous);
        for c in as_string.chars() {
            if c == '1' {
                p_ones += 1;
            }
        }
        if p_ones == ones {
            println!("{:?}, {:b}", previous, previous);
            break;
        }
        previous -= 1;
    }
    let mut next: u32 = n + 1;
    loop {
        let mut n_ones: u32 = 0;
        let as_string: String = format!("{:b}", next);
        for c in as_string.chars() {
            if c == '1' {
                n_ones += 1;
            }
        }
        if n_ones == ones {
            println!("{:?}, {:b}", next, next);
            break;
        }
        next += 1
    }
    return (next, previous);
}

fn main() -> () {
    let n: u32 = 42;
    println!("{:?}, {:?}", n, get_next_and_prev_by_ones(n));
}
#+end_example

get bit at index

: fn get_bit_at(n: u32, index: u32) -> u32 {
:     let bit: u32 = if ((n & (1 << index)) > 0) { 1 } else { 0 };
:     println!("{:?}, {:b}, {:?}", index, n, bit);
:     return bit;
: }

set bit at index

: fn set_bit_at(n: u32, index: u32, b: bool) -> u32 {
:     if b {
:         return n | (1 << index);
:     } else {
:         let mask: u32 = !(1 << index);
:         return n & mask;
:     }
: }

- when flip on a 0, balance flipping off a 1;
- flip on a bit at i and flip off a bit at j, the number changes by 2^i - 2^j.
- to get a bigger number with the same number of 1s and 0s, i must be bigger
  than j.

: // Find first one.
: while (!GetBit(n, index)) index++;
: // Turn on next zero.
: while (GetBit(n, index)) {
:     index++;
:     countOnes++;
: }
: n = SetBit(n, index, true);

** check_if_power_of_two

A is a power of 2 if (A & (A - 1) == 0.

A & B == 0 iff they don't have a bit in the same position

: 10101
: 01010
: -----
: 00000

A - 1 is flipping the LSB

: 10101 - 1
: 10100
:
: 10100 - 1
: 10011

if A don't share a bit with A - 1 then A has to be one of 10, 100, 1000,
10000... thus a power of two.

** diff_in_bit

using a XOR and counting the ones, are the "bit flips" to go from A to B.

fn bit_swaps(a: u32, b: u32) {
    let mut count: u32 = 0;
    let mut XOR = a ^ b;
    while XOR > 0 {
        count += XOR & 1; // count the LSB if one;
        XOR = XOR >> 1 // slide right;
    }
    return count;
}
